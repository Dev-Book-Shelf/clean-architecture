# 12장 컴포넌트

컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.  
자바의 경우 jar 파일이, 루비에서는 gem 파일이, 닷넷에서는 DLL이다.

여러 컴포넌트를 묶어서 .war 파일 같은 단일 아카이브로 만들 수도 있고,  
컴포넌트 각각을 .jar이나 .dll 같은 플러그인이나  
.exe 파일로 만들어서 독립적으로 배포할 수도 잇다.

## 컴포넌트의 간략한 역사

소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.

프로그램의 시작부에는 프로그램이 로드될 주소를 선언하는 오리진 구문이 나와야 했다.  
이 시절에는 프로그램의 위치가 한번 결정되면 재배치가 불가능했다.

이런 구시대에는 라이브러리 함수에 어떻게 접근했을까?  
개발자가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.

메모리는 한정적이기 때문에, 소스 코드 전체를 메모리에 상주시킬 수 없어 결국 컴파일러는 소스 코드를 여러 차례 읽어야 했고, 대규모 프로그램 컴파일에는 몇 시간씩 걸리곤 했다.

컴파일 시간을 단축하기 위해 프로그래머는 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리,  
함수 라이브러리를 개별적으로 컴파일하고, 컴파일된 바이너리를 메모리의 특정 위치에 로드

함수 라이브러리에 대한 심벌 테이블을 생성한 후 이를 이용해 애플리케이션 코드를 컴파일 했다.

하지만 애플리케이션 코드가 정해진 메모리 공간을 넘어가면 새 메모리 공간이 필요했다...

## 재배치성

재배치가 가능한 바이너리(relocatable binary)로 해결

로더에 재배치 코드가 자리할 위치 정보를 넣음  
이제 개발자는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다.

또 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 만들도록 수정되었다.  
따라서 라이브러리 함수를 로드할 위치만 정해지면 함수 이름을 참조로 가져와 링크할 수 있게 된다.(링킹 로더)

## 링커

링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.

작은 프로그램, 작은 라이브러리를 링크할 때는 잘 동작했지만, 프로그램의 규모가 커지자 프로그램을 로드하는데 오랜 시간이 걸리게 되었다.

로드와 링크로 단계를 나눠, 프로그래머가 링크 과정을 맡았다.

프로그램의 규모가 지속적으로 커져 컴파일-링크 시간이 계속 길어지게 되었으나  
무어의 법칙에 따라 디스크가 작아지고 빨라지고, 메모리는 저렴해져서  
로드와 링크를 동시에 할 수 있게 되었다.

## 결론

과거에는 초인적인 노력을 들여야 컴포넌트 플러그인 아키텍처를 적용할 수 있었지만, 이제는 기본으로 쉽게 사용할 수 있다.
